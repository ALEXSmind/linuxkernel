#第八章 进程调度与切换

##8.1硬件中断与软中断

##8.2进程调度的时机

##8.3调度算法

调度算法就是从就绪队列中选一个进程。一般来说他需要综合考虑以下因素：

* xxxx
* xxxx
* xxxx

###8.3.1 调度策略
Linux即作为服务器使用，又作为桌面PC使用，同时还是是主要的嵌入式设备操作系统，以满足不同的调度需求。
服务器的典型调度需求：

* xxxx
* xxxx
* xxxx

桌面系统的典型调度需求：

* xxxx
* xxxx
* xxxx

嵌入工实时控制系统的典型调度需求：

* xxxx
* xxxx
* xxxx

Linux支持三种基本的调度策略，以满足不同进程的调度需求。这相当于是按照进程的调度方式对进程进行分类。三种具体的策略如下：

* xxx
* xxx
* xxx


###8.3.2 CFS调度算法
CFS即为完全公平调度算法，其基本原理基于权重的动态优先级调度算法。每个进程在启动时会根据其优先级计算“理论运行时间”（CPU的欠债），然后每次运行都统计其“实际支行时间”（CPU的还款），调度算法就是选两者差值最大者。调度器每次都选“CPU欠的最多的”那个进程。

先用一个极端简化的例子来说明其原理：
假定CPU的总运行时间为60分钟，每15分钟调度一次。

| 进程    | 权重   | 理论运行时间  |
| ------ |:----- :| -----:      |
| A      | 1      | 10 分钟      |
| B      | 2      | 20 分钟    |
| C      | 3      | 30 分钟   |

首次调度时，CPU欠C30分钟，最多，所以C被调度到执行了15分钟，相当于CPU还了C15分钟，就只欠C15分钟了；第二次调度时，就变成欠B最多了，20；B运行15分钟后，欠B5分钟，又变成欠C最多了；C再运行15分钟后，欠A最多了；然后A，然后B。调度结束。


其具体涉及相关代码主要有以下：

* Linux传统优先级与权重的转换关系
* 理论运行时间的估算
* 实际运行时间(vruntime)的估算优化
* 计算结果的排序与存储（rbtree）



##8.4 上下文切换
### 8.4.1 执行环境的切换
> 分析进程的切换大流程;

###8.4.2 switch_to
> 指令流的切换


###8.4.3 Linux系统的运行

> 对应视频 Linux系统的一般执行过程

##8.5 系统的运行综述
> 对应视频 Linux系统构架与执行过程概览

